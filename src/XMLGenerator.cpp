#include "aeg/XMLGenerator.h"
#include <math.h>

using namespace std;


string XMLGen::generateWorldFile()
{
printf("Generating world file start\n");
   list<string> terrainList;
   list<string> worldContent = XMLGen::generateWorld(50, false, terrainList);

   // Generate file name using time
   time_t seconds;
   time(&seconds);

   stringstream ss;
   ss << "AutoGeneratedWorld_" << seconds << ".sdf";
   string filename = ss.str();
   XMLGen::writeToFile(worldContent, filename);
   return filename;
}

string XMLGen::generateWorldFile(double length, bool continuous, list<string> terrainList)
{
   list<string> worldContent = XMLGen::generateWorld(length, continuous, terrainList);

   // Generate file name using time
   time_t seconds;
   time(&seconds);

   stringstream ss;
   ss << "AutoGeneratedWorld_" << seconds << ".sdf";
   string filename = ss.str();
   XMLGen::writeToFile(worldContent, filename);
   return filename;
}

list<string> XMLGen::generateWorld(double length, bool continuous, list<string> terrainList)
{
   list<string> world;
   string prefixSpacing = "";

   world.push_back(prefixSpacing + "<sdf version='1.4'>");
   world.push_back(prefixSpacing + "   <world name='testWorld'>");


printf("Generating light\n");
	//	Basic world requirements
	list<string> temp = generateLight();
	world.splice(world.end(), temp);

	temp = generateWorldPhysics();
	world.splice(world.end(), temp);

	temp = generateScene();
	world.splice(world.end(), temp);

	temp = generateSphericalCoordinates();
	world.splice(world.end(), temp);

	temp = generateGUI();
	world.splice(world.end(), temp);

	//	Add existing models
//   temp = getVehicle();
//   world.splice(world.end(), temp);

	//	Generate new models
	temp = generateGrassPlane();
	world.splice(world.end(), temp);

/*
        double point1[] = { 0.0, 0.0, 0.0 };
        double point2[] = { 50.0, 0.0, 0.0 };
        double point3[] = { 0.0, 50.0, 0.0 };

        vector<double> start (point1, point1 + sizeof(point1) / sizeof(double));
        vector<double> end   (point2, point2 + sizeof(point2) / sizeof(double));
        vector<double> third (point3, point3 + sizeof(point3) / sizeof(double));

        double width = 10;

        temp = generateStraightRoad(start, end, width);
	world.splice(world.end(), temp);
        temp = generateStraightRoad(start, third, width);
        world.splice(world.end(), temp);
        temp = generateStraightRoad(end, third, width);
	world.splice(world.end(), temp);


//	temp = generateStraightRoad(50.0, 7.0, 3.14159/4);
//	world.splice(world.end(), temp);
*/


   stringstream sstream;
   time_t seconds;
   time(&seconds);
   sstream << "road_" << seconds;
   string modelName = sstream.str();
   sstream.str(string());
printf("got road name\n");
   temp = pathGen.generatePath(length, continuous, terrainList, modelName);
   world.splice(world.end(), temp);
printf("finished splice\n");
   // Add plugins
//   temp = getVRCPlugin();
//   world.splice(world.end(), temp);

	world.push_back(prefixSpacing + "   </world>");
	world.push_back(prefixSpacing + "</sdf>");

	return world;
}

list<string> XMLGen::generateModel()
{
	list<string> model;
	return model;
}

list<string> XMLGen::generateLink()
{
	list<string> link;

	//	collision
	//	visual
	//	velocity decay
	//	self_collide
	//	kinematic
	//	gravity
	

	return link;
}

list<string> XMLGen::generateLight()
{
	list<string> light;
	string prefixSpacing = "      ";

	light.push_back(prefixSpacing + "<light name='sun' type='directional'>");

	//	cast_shadows
	light.push_back(prefixSpacing + "   <cast_shadows>1</cast_shadows>");

	//	pose
	light.push_back(prefixSpacing + "   <pose>0 0 10   0 0 0</pose>");
	
	//	diffuse
	light.push_back(prefixSpacing + "   <diffuse>0.8 0.8 0.8 1</diffuse>");

	//	specular
	light.push_back(prefixSpacing + "   <specular>0.2 0.2 0.2 1</specular>");

	//	attenuation
	light.push_back(prefixSpacing + "   <attenuation>");
	light.push_back(prefixSpacing + "      <range>1000</range>");
	light.push_back(prefixSpacing + "      <constant>0.9</constant>");
	light.push_back(prefixSpacing + "      <linear>0.01</linear>");
	light.push_back(prefixSpacing + "      <quadratic>0.001</quadratic>");
	light.push_back(prefixSpacing + "   </attenuation>");

	//	direction
	light.push_back(prefixSpacing + "   <direction>-0.5 0.1 -0.9</direction>");

	light.push_back(prefixSpacing + "</light>");

	return light;
}

list<string> XMLGen::generateWorldPhysics()
{
	list<string> physics;
	string prefixSpacing = "      ";

	//	type
	physics.push_back(prefixSpacing + "<physics type='ode'>");

	//	max step size
	physics.push_back(prefixSpacing + "   <max_step_size>0.001</max_step_size>");

	//	real time factor
	physics.push_back(prefixSpacing + "   <real_time_factor>1</real_time_factor>");
	
	//	real time update rate
	physics.push_back(prefixSpacing + "   <real_time_update_rate>1000</real_time_update_rate>");
	
	//	gravity
	physics.push_back(prefixSpacing + "   <gravity>0 0 -9.8</gravity>");


	physics.push_back(prefixSpacing + "</physics>");

	return physics;
}

list<string> XMLGen::generateScene()
{
	list<string> scene;
	string prefixSpacing = "      ";

	scene.push_back(prefixSpacing + "<scene>");

	//	ambient
	scene.push_back(prefixSpacing + "   <ambient>0.4 0.4 0.4 1</ambient>");

	//	background
	scene.push_back(prefixSpacing + "   <background>0.7 0.7 0.7 1</background>");

	//	sky
	scene.push_back(prefixSpacing + "   <sky>");
	scene.push_back(prefixSpacing + "      <time>12</time>");
	scene.push_back(prefixSpacing + "      <clouds>");
	scene.push_back(prefixSpacing + "      </clouds>");
	scene.push_back(prefixSpacing + "   </sky>");

	//	shadows
	scene.push_back(prefixSpacing + "   <shadows>1</shadows>");

	scene.push_back(prefixSpacing + "</scene>");

	return scene;
}

list<string> XMLGen::generateSphericalCoordinates()
{
	list<string> coordinates;
	string prefixSpacing = "      ";

	coordinates.push_back(prefixSpacing + "<spherical_coordinates>");

	//	surface model
	coordinates.push_back(prefixSpacing + "   <surface_model>EARTH_WGS84</surface_model>");

	//	latitutde deg
	coordinates.push_back(prefixSpacing + "   <latitude_deg>0</latitude_deg>");

	//	longitude deg
	coordinates.push_back(prefixSpacing + "   <longitude_deg>0</longitude_deg>");

	//	elevation
	coordinates.push_back(prefixSpacing + "   <elevation>0</elevation>");

	//	heading deg
	coordinates.push_back(prefixSpacing + "   <heading_deg>0</heading_deg>");

	coordinates.push_back(prefixSpacing + "</spherical_coordinates>");

	return coordinates;
}

list<string> XMLGen::generateState()
{
	list<string> state;

	//	sim time
	//	

	return state;
}

list<string> XMLGen::generateGUI()
{
	list<string> gui;
	string prefixSpacing = "      ";

	gui.push_back(prefixSpacing + "<gui fullscreen='0'>");
	
	//	camera
	gui.push_back(prefixSpacing + "   <camera name='user_camera'>");
	gui.push_back(prefixSpacing + "      <pose>0 0 5  0 0.25 0.25</pose>");
	gui.push_back(prefixSpacing + "      <view_controller>orbit</view_controller>");
	gui.push_back(prefixSpacing + "   </camera>");

	gui.push_back(prefixSpacing + "</gui>");

	return gui;
}

list<string> XMLGen::generateGeometry()
{
	list<string> geometry;
	return geometry;
}

list<string> XMLGen::generateGrassPlane()
{
	list<string> road;
	string prefixSpacing = "      ";

	road.push_back(prefixSpacing + "<model name='grassPlane'>");
	road.push_back(prefixSpacing + "   <static>1</static>");

	road.push_back(prefixSpacing + "   <link name='roadLink_1'>");

	//	Collision
	road.push_back(prefixSpacing + "      <collision name='collision'>");
	road.push_back(prefixSpacing + "         <geometry>");
	road.push_back(prefixSpacing + "            <plane>");
	road.push_back(prefixSpacing + "               <normal>0 0 1</normal>");
	road.push_back(prefixSpacing + "               <size>100 100</size>");
	road.push_back(prefixSpacing + "            </plane>");
	road.push_back(prefixSpacing + "         </geometry>");
	road.push_back(prefixSpacing + "         <surface>");
	road.push_back(prefixSpacing + "            <bounce>");
	road.push_back(prefixSpacing + "            </bounce>");
	road.push_back(prefixSpacing + "            <friction>");
	road.push_back(prefixSpacing + "               <ode>");
	road.push_back(prefixSpacing + "                  <mu>100</mu>");
	road.push_back(prefixSpacing + "                  <mu2>50</mu2>");
	road.push_back(prefixSpacing + "               </ode>");
	road.push_back(prefixSpacing + "            </friction>");
	road.push_back(prefixSpacing + "            <contact>");
	road.push_back(prefixSpacing + "               <ode>");
	road.push_back(prefixSpacing + "               </ode>");
	road.push_back(prefixSpacing + "            </contact>");
	road.push_back(prefixSpacing + "         </surface>");
	road.push_back(prefixSpacing + "      </collision>");

	//	Visual
	road.push_back(prefixSpacing + "      <visual name='visual'>");
	road.push_back(prefixSpacing + "         <cast_shadows>0</cast_shadows>");
	road.push_back(prefixSpacing + "         <geometry>");
	road.push_back(prefixSpacing + "            <plane>");
	road.push_back(prefixSpacing + "               <normal>0 0 1</normal>");
	road.push_back(prefixSpacing + "               <size>100 100</size>");
	road.push_back(prefixSpacing + "            </plane>");
	road.push_back(prefixSpacing + "         </geometry>");
	road.push_back(prefixSpacing + "         <material>");
	road.push_back(prefixSpacing + "            <script>");
	road.push_back(prefixSpacing + "               <uri>file://media/materials/scripts/gazebo.material</uri>");
	road.push_back(prefixSpacing + "               <name>Gazebo/Green</name>");
	road.push_back(prefixSpacing + "            </script>");
	road.push_back(prefixSpacing + "         </material>");
	road.push_back(prefixSpacing + "      </visual>");

	road.push_back(prefixSpacing + "      <velocity_decay>");
	road.push_back(prefixSpacing + "         <linear>0</linear>");
	road.push_back(prefixSpacing + "         <angular>0</angular>");
	road.push_back(prefixSpacing + "      </velocity_decay>");

	road.push_back(prefixSpacing + "      <self_collide>0</self_collide>");
	road.push_back(prefixSpacing + "      <kinematic>0</kinematic>");
	road.push_back(prefixSpacing + "      <gravity>1</gravity>");

	road.push_back(prefixSpacing + "   </link>");

	road.push_back(prefixSpacing + "</model>");


	return road;
}

list<string> XMLGen::generatePathFromStraightRoads(list<vector<double> > inputList)
{
   return generateStraightRoad();
}

list<string> XMLGen::generateStraightRoad(double length, double width, double angle)
{
   double point[] = { 40.0, 0.0, 0.0 };
   vector<double> startingPoint (point, point + sizeof(point) / sizeof(double));
   return generateStraightRoad(startingPoint, length, width, angle);
}

list<string> XMLGen::generateStraightRoad(vector<double> start, vector<double> end, double width)
{
   double xLength = (start[0] - end[0]);
   double yLength = (start[1] - end[1]);
   double zLength = (start[2] - end[2]);
printf("start:\t(%f, %f, %f)\nend:\t(%f, %f, %f)\ndelta:\t(%f, %f, %f)\n", start[0], start[1], start[2], end[0], end[1], end[2], xLength, yLength, zLength);
   double length = sqrt(pow(xLength, 2) + pow(yLength, 2));
   double angle = atan (yLength / xLength);
printf("Angle:\t%f\tLength:\t%f\n", angle, length);
   return generateStraightRoad(start, length, width, angle);
}

list<string> XMLGen::generateStraightRoad(vector<double> start, double length, double width, double angle)
{
	list<string> road;

	string prefixSpacing = "      ";
stringstream sstream;
sstream << angle;
string id = sstream.str();
sstream.str(string());
	road.push_back(prefixSpacing + "<model name='straightRoad" + id +"'>");
	road.push_back(prefixSpacing + "   <static>1</static>");

	road.push_back(prefixSpacing + "   <link name='roadLink_1'>");

	//	pose calculations
//	stringstream sstream;
	sstream << (width / 2) + start[0];
	string xPos = sstream.str();
        sstream.str(string());
	
        sstream << (length / 2) + start[1];
	string yPos = sstream.str();
        sstream.str(string());

        sstream << 0.1 + start[2];
        string zPos = sstream.str();
        sstream.str(string());
	
        sstream << angle;
	string tempAngle = sstream.str();
        sstream.str(string());

	road.push_back(prefixSpacing + "   <pose>" + xPos + " " + yPos + " " + zPos + "  0 0 " + tempAngle + "</pose>");
	

	//	Collision
	road.push_back(prefixSpacing + "      <collision name='collision'>");
	road.push_back(prefixSpacing + "         <geometry>");
	road.push_back(prefixSpacing + "            <plane>");
	road.push_back(prefixSpacing + "               <normal>0 0 1</normal>");

	sstream << width;
	string tempWidth = sstream.str();
        sstream.str(string());

	sstream << length;
	string tempLength = sstream.str();
        sstream.str(string());

	road.push_back(prefixSpacing + "               <size>" + tempWidth + " " + tempLength + "</size>");
	road.push_back(prefixSpacing + "            </plane>");
	road.push_back(prefixSpacing + "         </geometry>");
	road.push_back(prefixSpacing + "         <surface>");
	road.push_back(prefixSpacing + "            <bounce>");
	road.push_back(prefixSpacing + "            </bounce>");
	road.push_back(prefixSpacing + "            <friction>");
	road.push_back(prefixSpacing + "               <ode>");
	road.push_back(prefixSpacing + "                  <mu>100</mu>");
	road.push_back(prefixSpacing + "                  <mu2>50</mu2>");
	road.push_back(prefixSpacing + "               </ode>");
	road.push_back(prefixSpacing + "            </friction>");
	road.push_back(prefixSpacing + "            <contact>");
	road.push_back(prefixSpacing + "               <ode>");
	road.push_back(prefixSpacing + "               </ode>");
	road.push_back(prefixSpacing + "            </contact>");
	road.push_back(prefixSpacing + "         </surface>");
	road.push_back(prefixSpacing + "      </collision>");

	//	Visual
	road.push_back(prefixSpacing + "      <visual name='visual'>");
	road.push_back(prefixSpacing + "         <cast_shadows>0</cast_shadows>");
	road.push_back(prefixSpacing + "         <geometry>");
	road.push_back(prefixSpacing + "            <plane>");
	road.push_back(prefixSpacing + "               <normal>0 0 1</normal>");
	road.push_back(prefixSpacing + "               <size>" + tempWidth + " " + tempLength + "</size>");
	road.push_back(prefixSpacing + "            </plane>");
	road.push_back(prefixSpacing + "         </geometry>");
	road.push_back(prefixSpacing + "         <material>");
	road.push_back(prefixSpacing + "            <script>");
	road.push_back(prefixSpacing + "               <uri>file://media/materials/scripts/gazebo.material</uri>");
	road.push_back(prefixSpacing + "               <name>Gazebo/FlatBlack</name>");
	road.push_back(prefixSpacing + "            </script>");
	road.push_back(prefixSpacing + "         </material>");
	road.push_back(prefixSpacing + "      </visual>");

	road.push_back(prefixSpacing + "      <velocity_decay>");
	road.push_back(prefixSpacing + "         <linear>0</linear>");
	road.push_back(prefixSpacing + "         <angular>0</angular>");
	road.push_back(prefixSpacing + "      </velocity_decay>");

	road.push_back(prefixSpacing + "      <self_collide>0</self_collide>");
	road.push_back(prefixSpacing + "      <kinematic>0</kinematic>");
	road.push_back(prefixSpacing + "      <gravity>1</gravity>");

	road.push_back(prefixSpacing + "   </link>");

	road.push_back(prefixSpacing + "</model>");


	return road;
}

list<string> XMLGen::generateStraightRoad()
{
	list<string> road;
	string prefixSpacing = "      ";

	road.push_back(prefixSpacing + "<model name='straightRoad'>");
	road.push_back(prefixSpacing + "   <static>1</static>");
	
	road.push_back(prefixSpacing + "   <link name='roadLink_1'>");
	road.push_back(prefixSpacing + "   <pose>0 0 0.1  0 0 0</pose>");

	//	Collision
	road.push_back(prefixSpacing + "      <collision name='collision'>");
	road.push_back(prefixSpacing + "         <geometry>");
	road.push_back(prefixSpacing + "            <plane>");
	road.push_back(prefixSpacing + "               <normal>0 0 1</normal>");
	road.push_back(prefixSpacing + "               <size>10 100</size>");
	road.push_back(prefixSpacing + "            </plane>");
	road.push_back(prefixSpacing + "         </geometry>");
	road.push_back(prefixSpacing + "         <surface>");
	road.push_back(prefixSpacing + "            <bounce>");
	road.push_back(prefixSpacing + "            </bounce>");
	road.push_back(prefixSpacing + "            <friction>");
	road.push_back(prefixSpacing + "               <ode>");
	road.push_back(prefixSpacing + "                  <mu>100</mu>");
	road.push_back(prefixSpacing + "                  <mu2>50</mu2>");
	road.push_back(prefixSpacing + "               </ode>");
	road.push_back(prefixSpacing + "            </friction>");
	road.push_back(prefixSpacing + "            <contact>");
	road.push_back(prefixSpacing + "               <ode>");
	road.push_back(prefixSpacing + "               </ode>");
	road.push_back(prefixSpacing + "            </contact>");
	road.push_back(prefixSpacing + "         </surface>");
	road.push_back(prefixSpacing + "      </collision>");

	//	Visual
	road.push_back(prefixSpacing + "      <visual name='visual'>");
	road.push_back(prefixSpacing + "         <cast_shadows>0</cast_shadows>");
	road.push_back(prefixSpacing + "         <geometry>");
	road.push_back(prefixSpacing + "            <plane>");
	road.push_back(prefixSpacing + "               <normal>0 0 1</normal>");
	road.push_back(prefixSpacing + "               <size>10 100</size>");
	road.push_back(prefixSpacing + "            </plane>");
	road.push_back(prefixSpacing + "         </geometry>");
	road.push_back(prefixSpacing + "         <material>");
	road.push_back(prefixSpacing + "            <script>");
	road.push_back(prefixSpacing + "               <uri>file://media/materials/scripts/gazebo.material</uri>");
	road.push_back(prefixSpacing + "               <name>Gazebo/FlatBlack</name>");
	road.push_back(prefixSpacing + "            </script>");
	road.push_back(prefixSpacing + "         </material>");
	road.push_back(prefixSpacing + "      </visual>");

	road.push_back(prefixSpacing + "      <velocity_decay>");
	road.push_back(prefixSpacing + "         <linear>0</linear>");
	road.push_back(prefixSpacing + "         <angular>0</angular>");
	road.push_back(prefixSpacing + "      </velocity_decay>");

	road.push_back(prefixSpacing + "      <self_collide>0</self_collide>");
	road.push_back(prefixSpacing + "      <kinematic>0</kinematic>");
	road.push_back(prefixSpacing + "      <gravity>1</gravity>");

	road.push_back(prefixSpacing + "   </link>");

	road.push_back(prefixSpacing + "</model>");


	return road;
}


list<string> XMLGen::getVehicle()
{
   list<string> vehicle;

   vehicle.push_back("<include>");
   vehicle.push_back("   <uri>model://drc_vehicle_xp900</uri>");
   vehicle.push_back("   <pose>2 -2 0  0 0 0</pose>");
   vehicle.push_back("</include>");

   return vehicle;
}

list<string> XMLGen::getVRCPlugin()
{
   list<string> plugin;

   plugin.push_back("<plugin filename=\"libVRCPlugin.so\" name=\"vrc_plugin\">");
   plugin.push_back("   <atlas>");
   plugin.push_back("      <model_name>atlas</model_name>");
   plugin.push_back("      <pin_link>utorso</pin_link>");
   plugin.push_back("   </atlas>");
   plugin.push_back("   <drc_vehicle>");
   plugin.push_back("      <model_name>drc_vehicle_xp900</model_name>");
   plugin.push_back("      <seat_link>polaris_range_xp900::chassis</seat_link>");
   plugin.push_back("   </drc_vehicle>");
   plugin.push_back("</plugin");

   return plugin;
}



void XMLGen::writeToFile(list<string> textToWrite, string filename)
{
	ofstream outputFile(filename.c_str(), ofstream::out);
/*
	for (string line : textToWrite)
	{
		outputFile << line << endl;
	}
*/

	for(list<string>::iterator iter = textToWrite.begin(); textToWrite.end() != iter ;iter++)
	{
		outputFile << *iter << endl;
	}

	outputFile.flush();
	outputFile.close();
}
